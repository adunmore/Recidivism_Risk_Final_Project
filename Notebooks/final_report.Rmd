---
title: 'Predicting Recidivism in Broward County'
author: '[Aaron Dunmore](mailto:adunmore@andrew.cmu.edu) and [Minseon Lee] (mailto:minseonl@andrew.cmu.edu)'
output:
  github_document:
  toc: TRUE
  toc_float: TRUE
---


```{r, include=FALSE}
library(DBI)
library(RSQLite)
library(tidyverse)

conn <- dbConnect(drv = dbDriver('SQLite'),
                  '../Data/modified/compas.db')
compas <- dbGetQuery(conn = conn,
           statement = 'select * from casearrest
                          JOIN people on casearrest.person_id = people.id')
```
## Introduction

In this project, we analyze a large data set of ~100k records of criminal charges, taken from the Broward County, FL court system. We create, evaluate, and validate models predicting risk of recidivism, and risk of violent recidivism.

In section 1, we detail our data processing steps. After exploring the data, we synthesized several variables to use in our analysis.

In section 2, we discuss some basic findings from exploratory analysis, establishing preliminary evidence of links between recidivism and the independent variables we have selected.

In section 3, we train 5 different models to predict risk of recidivism and risk of violent recidivism.

In section 4, we evaluate our models, and choose a model for each problem.

In sections 5, 6, and 7, we analyze our final models: determining variable importance, studying whether our models' predictions were biased across demographic groups, and comparing our models' performances to the performance of the COMPAS risk assessment tool.

Our source data was published by ProPublica, in [their analysis of the COMPAS risk assessment tool](https://github.com/propublica/compas-analysis).

### Problem Framing

We develop a models to predict the risk that an individual who has just been arrested will be charged for another crime of misdemeanor class (or more severe) within the next two years (likewise for violent crimes).

## 1. Data Processing

### 1.1. Introduction

#### a) compas.db
Our source data is a [sqlite database file sourced from ProPublica's Github](https://github.com/propublica/compas-analysis/blob/master/compas.db). It includes 5 relevant tables:

Name | Description
:-|-
casearrest | The main table of interest. Contains one row per criminal charge per arrest event.
people | One row per person. Includes basic information such as sex, race, date of birth, and juvenile criminal history.
charge | One row per charge. Includes detailed information about charges, including charge descriptions.
jailhistory | Includes each individual's history of jail custody
prisonhistory | Includes each individual's history of prison custody.

#### b) Descriptives

compas includes `r nrow(compas)` arrest-charges, which represent `r compas %>% select(person_id, arrest_date) %>% distinct() %>% count()` arrest events for `r length(unique(compas$person_id))` people. Arrest dates range from `r as.Date(min(compas$arrest_date))` to `r as.Date(max(compas$arrest_date))`

### 1.2. Transformations

We synthesized a number of variables for each arrest event.

#### a) violent_offense

We identified whether each arrest event was charged as a violent offense. We followed the [FBI's definition of violent crime](https://ucr.fbi.gov/crime-in-the-u.s/2018/crime-in-the-u.s.-2018/topic-pages/violent-crime): murder, rape, robbery, and aggravated assault.

We used simple text filters on each charge's description to identify each crime as either violent or non-violent. 

This method identified just `r compas %>% select(person_id, arrest_date, recidivated_violent) %>% filter(recidivated_violent == 1) %>% distinct() %>% nrow()` violent crimes, so it might have failed to identify some violent crimes in the dataset. With better information about how the Broward County court system labels violent crimes, we could have performed this step with higher confidence. This is a limitation of our analysis of violent recidivism.

This also means that class imbalance will be a concern as we try to predict violent recidivism. This issue is addressed in section 3.1.b

#### b) recidivism and violent_recidivism

We also identifed whether each arrest event was followed up by an event of recidivism (or violent recidivism). We followed the definition of recidivism suggested by the authors of ProPublica's analysis of the COMPAS Recidivism Algorithm: recidivism occurs when an individual commmits a new (violent) felony or misdemeanor offense within two years of a given arrest.

If a given arrest event occurred <2 years before the end of the data (`r as.Date(max(compas$arrest_date))`), then we could not conclude whether or not the arrest was followed by recidivism. Such cases were excluded from our training data.

#### c) prior criminal history

We generated variables summarizing each individual's prior criminal history leading up to the arrest in question. We counted the number of prior (violent) misdemeanor & felony offenses the individual had been charged for overall, within 5 years, and within 2 years.

#### d) Arrest age

Using each individual's date of birth, we calculated their age at the time of each arrest.

### Other Processing

#### a) Filtering Municipal Offenses

We excluded Municipal Offenses from this data. We neither counted them as recidivism events, nor included them in our training or test data.

#### b) Data Cleaning

The original dataset included some arrest events labeled as taking place in the future (2020 and later). We removed these events from the data.

## 2. Exploration

We examined how recidivism and violent recidivism differ across our indipendent variables. Based on the plots, for both recidivism and violent recidivism, younger defendants are more likely to recidivate. Men are more likely to recidivate than women. Native American and African-American are more likely to recidivate. Defendants with more overall prior arrests are more likely to recidivate. For other variables, such as charge degree and the number of prior arrests within the last two years and five years, we did not find any interesting pattern.

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=6, fig.path='Figs/',
                      warning=FALSE, message=FALSE)
```




```{r setup, include=FALSE, echo=FALSE}

library(tidyverse)
library(gridExtra)

df <- read_csv("../Data/modified/arrest_history.csv")
df_violent <- read_csv("../Data/modified/arrest_history_violent.csv")
df_raw <- read_csv("../Data/modified/arrest_history_raw.csv")


df$arrest_age_category <- factor(df$arrest_age_category, 
                                 levels = c("Less than 25", "25 - 45", "Greater than 45"))

df_violent$arrest_age_category <- factor(df_violent$arrest_age_category, 
                                 levels = c("Less than 25", "25 - 45", "Greater than 45"))

```

### 2.1. Recidivism plots

```{r two-year recidivism, echo=FALSE}
r1 <- df %>% 
  ggplot(aes(x = race, fill = recidivated)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Recidivism across race") +
  theme(legend.position = "none") + 
  coord_flip()



r2 <- df %>% 
  ggplot(aes(x = arrest_age_category, fill = recidivated)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Recidivism across age", x = "age") +
  theme(legend.position = "none")


r3 <- df %>% 
  ggplot(aes(x = sex, fill = recidivated)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Recidivism across gender", x = "gender")


r4 <- df %>% 
  ggplot(aes(x = prior_arrest_overall, fill = recidivated)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Recidivism across the number\nof prior arrests", x = "prior arrests") +
  theme(legend.position = "none")

grid.arrange(r3, r2, r1, r4, nrow = 2)
```

### 2.2 Violent recidivism plots

```{r two-year violent recidivism, echo=FALSE}
vr1 <- df_violent %>% 
  ggplot(aes(x = race, fill = recidivated_violent)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Violent recidivism across\nrace", x = "race") +
  theme(legend.position = "none") + 
  coord_flip()

vr2 <- df_violent %>% 
  ggplot(aes(x = arrest_age_category, fill = recidivated_violent)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Violent recidivism across age", x = "age") +
  theme(legend.position = "none")

vr3 <- df_violent %>% 
  ggplot(aes(x = sex, fill = recidivated_violent)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Violent recidivism across gender", x = "gender") 

vr4 <- df_violent %>% 
  ggplot(aes(x = prior_arrest_overall, fill = recidivated_violent)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values=c('lightgray', 'black')) +
  labs(title = "Violent recidivism across the number\nof prior arrests", x = "prior arrests") +
  theme(legend.position = "none")


grid.arrange(vr3, vr2, vr1, vr4, nrow = 2)


```



## 3. Modeling

```{r, echo=FALSE, include=FALSE}
library(tidyverse)
library(caret)
library(ggplot2)
library(ggthemes)
library(broom)
library(fastDummies)
library(xgboost)
library(ranger)
library(lubridate)
library(scales)
library(pROC)
library(plotROC)
# install.packages("ranger")
# install.packages("xgboost")
# install.packages("fastDummies")
```

### 3.1 Loading & Preprocessing

```{r loading data}

arrest_history <- read_csv("../Data/modified/arrest_history.csv") %>% 
  mutate(race = as.factor(race),
    arrest_age_category = as.factor(arrest_age_category),
    sex = as.factor(sex),
    recidivated = as.factor(recidivated)) %>% 
  select(-person_id) %>% 
  arrange(arrest_date)

# colnames(arrest_history)


arrest_history_violent <- read_csv("../Data/modified/arrest_history_violent.csv") %>% 
  mutate(race = as.factor(race),
    arrest_age_category = as.factor(arrest_age_category),
    sex = as.factor(sex),
    recidivated_violent = as.factor(recidivated_violent)) %>% 
  select(-person_id) %>% 
  arrange(arrest_date)

# colnames(arrest_history_violent)


```

#### a) Time-based Train & Test Splits

We have to take care to address the temporal nature of our data in our validation and train-test schemes. Our solution is to split the data on the basis of time.

We create a ~70-30 train-test split, with the test set as the last 3 years of the data set.

```{r train & test sets}
arrest_history_train <- arrest_history %>% 
  filter(arrest_date < ymd(max(.$arrest_date)) - years(3)) %>% 
  select(-arrest_date)

arrest_history_test <- arrest_history %>% 
  filter(arrest_date > ymd(max(.$arrest_date)) - years(3)) %>% 
  select(-arrest_date)

arrest_history_violent_train <- arrest_history_violent %>% 
  filter(arrest_date < ymd(max(.$arrest_date)) - years(3)) 

arrest_history_violent_test <- arrest_history_violent %>% 
  filter(arrest_date > ymd(max(.$arrest_date)) - years(3)) %>% 
  select(-arrest_date)
```

#### b) Upsampling

Class imbalance is a major issue with our violent recidivism dataset. Just `r nrow(arrest_history_violent %>% filter(recidivated_violent == 'yes'))` of the `r nrow(arrest_history_violent)` rows in our violent recidivism dataset represent violent recidivism events, a class imbalance of `r percent(3185 / 43755)`. 

We address this problem by upsampling the violent recidivism training set using caret's built in upsampling function.

```{r}
arrest_history_violent_upsample <- upSample(x = arrest_history_violent_train[, -2],
                                          y = arrest_history_violent_train$recidivated_violent) %>% 
  arrange(arrest_date) %>% 
  select(-Class, -arrest_date) 

arrest_history_violent_train <- arrest_history_violent_train %>% select(-arrest_date)
arrest_history_violent_length <- nrow(arrest_history_violent_upsample)
```

#### c) Time-based validation scheme

This code defines variables used by our time-based validation set schemes.

```{r}
arrest_history_length <- nrow(arrest_history_train)

arrest_history_violent_length <- nrow(arrest_history_violent_train)

```

### 3.2 Fitting models

#### a) Logistic

```{r logistic recidivism, warning=FALSE}
slice_size <- floor(arrest_history_length / 100)
trControl_logit <- trainControl(method = "timeslice",
                              initialWindow = slice_size,
                              horizon = slice_size,
                              skip = slice_size,
                              summaryFunction = twoClassSummary,
                              classProbs = TRUE,
                              fixedWindow = TRUE,
                              savePredictions = TRUE)

recidivism_logit <- train(recidivated ~ .,
                    data = arrest_history_train,
                    method = "glm",
                    family = binomial,
                    trControl = trControl_logit)
```


```{r logistic violent recidivism, warning=FALSE}

slice_size <- floor(arrest_history_violent_length / 100)
trControl_logit_violent <- trainControl(method = "timeslice",
                              initialWindow = slice_size,
                              horizon = slice_size,
                              skip = slice_size,
                              summaryFunction = twoClassSummary,
                              classProbs = TRUE,
                              fixedWindow = TRUE)




recidivism_violent_logit <- train(recidivated_violent ~ .,
                    data = arrest_history_violent_upsample,
                    method = "glm",
                    family = binomial,
                    trControl = trControl_logit)
```

#### b) Regularized

For regularized regressions (and a few other model types) we used a caching strategy to save us time when rerunning our notebook on unchanged data and modeling code.

```{r lasso recidivism}
slice_size <- floor(arrest_history_length / 100)
trControl_reg <- trainControl(method = "timeslice",
                             initialWindow = slice_size,
                             horizon = slice_size,
                             skip = slice_size,
                             summaryFunction = twoClassSummary,
                             fixedWindow = TRUE,
                             classProbs = TRUE,
                             savePredictions = TRUE)

cache_string <- '../Cache/recidivism_reg.rds'

if(file.exists(cache_string)) {
  recidivism_reg <- readRDS(file = cache_string)
  print(str_c('last run at: ', file.info(cache_string)$ctime))
} else {
recidivism_reg <- train(recidivated ~ .,
                    data = arrest_history_train,
                    method = "glmnet",
                    family = 'binomial',
                    trControl = trControl_reg
                    )
saveRDS(recidivism_reg, cache_string)
}
```

```{r lasso violent recidivism}
slice_size <- floor(arrest_history_violent_length / 100)
trControl_reg <- trainControl(method = "timeslice",
                             initialWindow = slice_size,
                             horizon = slice_size,
                             skip = slice_size,
                             fixedWindow = TRUE,
                             summaryFunction = twoClassSummary,
                             classProbs = TRUE)

cache_string <- '../Cache/recidivism_violent_reg.rds'

if(file.exists(cache_string)) {
  recidivism_violent_reg <- readRDS(file = cache_string)
  print(str_c('last run at: ', file.info(cache_string)$ctime))
} else {
recidivism_violent_reg <- train(recidivated_violent ~ .,
                    data = arrest_history_violent_upsample,
                    method = "glmnet",
                    family = 'binomial',
                    trControl = trControl_reg
                    )
saveRDS(recidivism_violent_reg, cache_string)
}
```



#### c) Tree

Note: rpart and tree::tree() are both implementations of the same recursive partitioning algorithm.

See details section:
https://www.rdocumentation.org/packages/rpart/versions/4.1-15/topics/rpart

Because of the heavy class imbalance present in our violent recidivism dataset, and because tree models work poorly in conditions of class imbalance, we did not train a tree model for that problem.

```{r tree recidivism}
slice_size <- floor(arrest_history_length / 10)
trControl_tree <- trainControl(method = "timeslice",
                              initialWindow = slice_size,
                              horizon = slice_size,
                              skip = slice_size,
                              summaryFunction = twoClassSummary,
                              classProbs = TRUE,
                              fixedWindow = TRUE)

recidivism_tree <- train(recidivated ~ .,
                    data = arrest_history_train,
                    method = "rpart",
                    trControl = trControl_tree)
```

#### d) Random Forest

```{r rf recidivism}
slice_size <- floor(arrest_history_length / 10)
trControl_rf <- trainControl(method = "timeslice",
                             initialWindow = slice_size,
                             horizon = slice_size,
                             skip = slice_size,
                             fixedWindow = TRUE,
                             summaryFunction = twoClassSummary,
                             classProbs = TRUE)


cache_string <- '../Cache/recidivism_rf.rds'

if(file.exists(cache_string)) {
  recidivism_rf <- readRDS(file = cache_string)
  print(str_c('last run at: ', file.info(cache_string)$ctime))
} else {
recidivism_rf <- train(recidivated ~ .,
                    data = arrest_history_train,
                    method = "ranger",
                    trControl = trControl_rf
                    )

saveRDS(recidivism_rf, file = cache_string)
}
```

```{r rf violent recidivism}

slice_size <- floor(arrest_history_violent_length / 10)
trControl_rf <- trainControl(method = "timeslice",
                             initialWindow = slice_size,
                             horizon = slice_size,
                             skip = slice_size,
                             fixedWindow = TRUE,
                             summaryFunction = twoClassSummary,
                             classProbs = TRUE)


cache_string <- '../Cache/recidivism_violent_rf.rds'

if(file.exists(cache_string)) {
  recidivism_violent_rf <- readRDS(file = cache_string)
  print(str_c('last run at: ', file.info(cache_string)$ctime))
} else {
recidivism_rf_violent <- train(recidivated_violent ~ .,
                    data = arrest_history_violent_upsample,
                    method = "ranger",
                    trControl = trControl_rf
                    )

saveRDS(recidivism_violent_rf, file = cache_string)
}




```


#### e) Boosting

```{r boosting recidivism}

cache_string <- '../Cache/recidivism_boost.rds'


slice_size <- floor(arrest_history_length / 10)
trControl_boost <- trainControl(method = "timeslice",
                             initialWindow = slice_size,
                             horizon = slice_size,
                             skip = slice_size,
                             fixedWindow = TRUE,
                             summaryFunction = twoClassSummary,
                             classProbs = TRUE)

if(file.exists(cache_string)) {
  recidivism_boost <- readRDS(file = cache_string)
} else {
  recidivism_boost <- train(recidivated ~ .,
                    data = arrest_history_train,
                    method = "xgbTree",
                    trControl = trControl_boost
                    )
  saveRDS(recidivism_boost, file = cache_string)
}
```

```{r boosting violent recidivism}

cache_string <- '../Cache/recidivism_boost_violent.rds'


slice_size <- floor(arrest_history_violent_length / 10)
trControl_boost <- trainControl(method = "timeslice",
                             initialWindow = slice_size,
                             horizon = slice_size,
                             skip = slice_size,
                             fixedWindow = TRUE,
                             summaryFunction = twoClassSummary,
                             classProbs = TRUE)

if(file.exists(cache_string)) {
  recidivism_violent_boost <- readRDS(file = cache_string)
} else {
  recidivism_violent_boost <- train(recidivated_violent ~ .,
                    data = arrest_history_violent_upsample,
                    method = "xgbTree",
                    trControl = trControl_boost
                    )
  saveRDS(recidivism_violent_boost, file = cache_string)
}




```

## 4. Model Selection

### 4.1 Model Evaluation
#### a) Generating Test Set Predictions

```{r predictions}
testdata_violent <- arrest_history_violent_test

# Logit
recidivism_logit.pred <- predict(recidivism_logit, 
                                 newdata = arrest_history_test, 
                                 type = 'prob')
recidivism_violent_logit.pred <- predict(recidivism_violent_logit, 
                                         newdata = arrest_history_violent_test, 
                                         type = 'prob')




# Regularized
recidivism_reg.pred <- predict(recidivism_reg, 
                               newdata = arrest_history_test, 
                               type = 'prob')


recidivism_violent_reg.pred <- predict(recidivism_violent_reg, 
                                       newdata = arrest_history_violent_test,
                                       type = 'prob')



# Tree
recidivism_tree.pred <- predict(recidivism_tree,
                                newdata = arrest_history_test, 
                                type = 'prob')


# RF
recidivism_rf.pred <- predict(recidivism_rf, 
                              newdata = arrest_history_test, 
                              type = 'prob')



recidivism_violent_rf.pred <- predict(recidivism_violent_rf, 
                                      newdata = arrest_history_violent_test, 
                                      type = 'prob')


# Boosted Tree
recidivism_boost.pred <- predict(recidivism_boost, 
                                 newdata = arrest_history_test, type = 'prob')


recidivism_violent_boost.pred <- predict(recidivism_violent_boost, 
                                         newdata = arrest_history_violent_test, 
                                         type = 'prob')

```

#### b) Sensitivity/Specificity

We compared models on the basis of specificity & sensitivity. For this problem statement, we wanted a model with high specificity, because of the costs of imprisonment to an individual who is at low risk of recidivation.

```{r}
# recidivism
logit <- recidivism_logit$results[c("Spec", "Sens")] # logistic

recidivism_reg$bestTune # regularization
reg <- dplyr::slice(recidivism_reg$results, 6)[c("Spec", "Sens")]

recidivism_boost$bestTune
boost <- dplyr::slice(recidivism_boost$results, 25)[c("Spec", "Sens")] # boost

recidivism_rf$bestTune
rf <- dplyr::slice(recidivism_rf$results, 1)[c("Spec", "Sens")] # rf

recidivism_tree$bestTune
tr <- dplyr::slice(recidivism_rf$results, 2)[c("Spec", "Sens")] # tree


rbind(logit = logit,
      reg = reg,
      boost = boost,
      rf = rf, 
      tr = tr)
```

Our logistic regression and boosted tree achieve comparable performance in both specificity and sensitivity. 

However, the logistic regression achieves higher sensitivity (~37.5% higher), for only a small loss in specificity. 

```{r}
# violent recidivism
recidivism_violent_boost$bestTune
boost_v <- dplyr::slice(recidivism_violent_boost$results, 4)[c("Spec", "Sens")]

logit_v <- recidivism_violent_logit$results[c("Spec", "Sens")]

recidivism_violent_reg$bestTune
reg_v <- dplyr::slice(recidivism_violent_reg$results, 3)[c("Spec", "Sens")]

recidivism_violent_rf$bestTune
rf_v <- dplyr::slice(recidivism_violent_rf$results, 4)[c("Spec", "Sens")]

rbind(boost_v = boost_v,
      logit_v = logit_v,
      reg_v = reg_v,
      rf_v = rf_v)
```

The boost model has much higher specificity compared to other models, making it a good candidate for our choice to predict violent recidivism.

#### c) Calculating Calibration & Lift Curves

A note: For some reason, the caret calibration function inverted our results. For example: in the case of the .875 to .925 bin, for which the calibration function estimated an observed event percentage of ~5%, manual calculations show the true observed event percentage was approximately 95%.

```{r}
cal_results <- data.frame(recidivated = arrest_history_test$recidivated,
                           logit = recidivism_logit.pred$yes)

cal_results %>% 
  filter(logit > .875 & logit < .925) %>% 
  group_by(recidivated) %>% 
  summarise(n())
```


For this reason, we invert the y-axis on our calibration plots. This gives us plots like what we would expect to see.

```{r Recidivism Calibration Plots}
cal_results <- data.frame(recidivated = arrest_history_test$recidivated,
                           logit = recidivism_logit.pred$yes,
                           reg = recidivism_reg.pred$yes,
                           tree = recidivism_tree.pred$yes,
                           rf = recidivism_rf.pred$yes,
                           boost = recidivism_boost.pred$yes)

cal_object <- calibration(recidivated ~ logit + reg + tree + rf + boost, data = cal_results,
            cuts = 20) 

cal_object$data$Percent <- ifelse(cal_object$data$Percent == 0, 0, 100 - cal_object$data$Percent)

cal_object %>% plot(auto.key = list(columns = 3,
                                          lines = TRUE,
                                          points = FALSE))


```
From this calibration curve, it appears that the logistic regression has slightly more stable performance than other models: At lower values of predicted probability, it stays closer to the diagonal than other models, such as our boosted tree.


```{r Violent Recidivism Calibration Plots}

cal_results_violent <- data.frame(recidivated_violent = arrest_history_violent_test$recidivated_violent,
                           logit = recidivism_violent_logit.pred$yes,
                           reg = recidivism_violent_reg.pred$yes,
                           rf = recidivism_violent_rf.pred$yes,
                           boost = recidivism_violent_boost.pred$yes)

cal_object <- calibration(recidivated_violent ~ logit + reg + rf + boost, data = cal_results_violent,
            cuts = 20) 

cal_object$data$Percent <- ifelse(cal_object$data$Percent == 0, 0, 100 - cal_object$data$Percent)

cal_object %>% plot(auto.key = list(columns = 3,
                                          lines = TRUE,
                                          points = FALSE))

```

This calibration plot demonstrates that, when comparing predicted and observed probabilities of violent recidivism, all of our models perform poorly. Observed percentage is below 20% for all of our models.

We could have used recalibration to fix this problem. 


### 4.2 Choice of Model

#### a) Recidivism

Comparing specificity and sensitivity across all of our models, our logistic regression performed the best in terms of the tradeoff between the two. And our calibration plot showed no meaningful difference in performance between our logistic regression and our other model.

Furthermore, the logistic regression's interpretability makes it desirable in our problem setting, where justice system officials might want to understand the factors contributing to a particular predicted risk score.

For these reasons, we selected the logistic regression as our model predicting recidivism.


#### b) Violent Recidivism

Our boosted tree was our only model predicting violent recidivism that performed well in terms of specificity. A calibration plot showed no difference between the performance of our boosted tree and that of our other models.

We selected our boosted tree as our model predicting violent recidivism.

## 5. Important Variables

### 5.1. Recidivism

```{r}
varImp(recidivism_logit)
```
For redicivism, age, recent criminal history, and misdemeanor status, and race accounted for the most important variables.


### 5.2. Violent recidivism

```{r}
varImp(recidivism_violent_logit)
```
For violent recidivism, prior arrest within two years, the number of prior arrests associated with violent charge, age are important predictors.



## 6. Racial, gender, and age bias

### 6.1 Bias in recidivism
```{r}

# summary(recidivism_logit)

intercept <- recidivism_logit$finalModel$coefficients['(Intercept)']
raceWhite <- recidivism_logit$finalModel$coefficients["raceCaucasian"]
ageYoung <- recidivism_logit$finalModel$coefficients["`arrest_age_categoryLess than 25`"]
sexMale <- recidivism_logit$finalModel$coefficients["sexMale"]
misdemeanor_1 <- recidivism_logit$finalModel$coefficients["charge_degree_.M3.TRUE"]


control <- exp(intercept) / (1 + exp(intercept))
exp(raceWhite) / (1 - control + (control * exp(raceWhite)))
exp(ageYoung) / (1 - control + (control * exp(ageYoung)))
exp(sexMale) / (1 - control + (control * exp(sexMale)))
exp(misdemeanor_1) / (1 - control + (control * exp(misdemeanor_1)))

```

According to the model, all else held constant, whites are 11% less likely to recidivate than blacks. Young people (those less than 25 years old) are predicted as being 20% more likely to recidivate than middle-aged people. Men are 9.5% more likely to recidivate than women. And if an arrest is charged as a 3rd degree Misdemeanor, it is twice as likely to be followed by recidivism than not.

### 6.2. Bias in violent recidivism

```{r}


# summary(recidivism_violent_logit)



intercept <- recidivism_violent_logit$finalModel$coefficients['(Intercept)']
raceWhite <- recidivism_violent_logit$finalModel$coefficients["raceCaucasian"]
ageYoung <- recidivism_violent_logit$finalModel$coefficients["`arrest_age_categoryLess than 25`"]
sexMale <- recidivism_violent_logit$finalModel$coefficients["sexMale"]
misdemeanor_1 <- recidivism_violent_logit$finalModel$coefficients["charge_degree_.M3.TRUE"]


control <- exp(intercept) / (1 + exp(intercept))
exp(raceWhite) / (1 - control + (control * exp(raceWhite)))
exp(ageYoung) / (1 - control + (control * exp(ageYoung)))
exp(sexMale) / (1 - control + (control * exp(sexMale)))




```

According to the model, all else held constant, whites are 17% less likely to recidivate than blacks. Young people (those less than 25 years old) are predicted as being 38% more likely to recidivate than middle-aged people. Men are 15% less likely to recidivate than women. 


### 6.3 Observed recidivism rates per-score level across demographic groups

In this section, we look for disparities in the observed recidivism rates of individuals within the same risk classes, in different demographic groups.

We performed this analysis across race, age, and sex.

- Defining low, medium, and high risk categories

We mapped our estimates of recidivism risk to low, medium, and high-risk categories. To allow for direct comparison to the COMPAS scores, we developed a method of mapping recidivism risk estimates to risk categories.

First, we calculated deciles of predicted (violent) recidivism risk. Then, we mapped arrest events in deciles 0-4 to low-risk, events in deciles 5-8 to medium-risk, and events in deciles 9-10 to high risk.

```{r}
deciles <- c(.1, .2, .3, .4, .5, .6, .7, .8, .9, 1)

deciles <- quantile(recidivism_logit.pred$yes, deciles) # generates deciles based on predicted probabilities


# adding column for raw model prediction scores
arrest_history_test <- cbind(arrest_history_test, predict(recidivism_logit, arrest_history_test, type = 'prob')$yes) %>%
  rename(recid_risk = `predict(recidivism_logit, arrest_history_test, type = "prob")$yes`) %>% 
  mutate(decile_score = case_when( # adding column for decile score
    recid_risk < deciles[1] ~ 0,
    recid_risk < deciles[1] ~ 1,
    recid_risk < deciles[2] ~ 2,
    recid_risk < deciles[3] ~ 3,
    recid_risk < deciles[4] ~ 4,
    recid_risk < deciles[5] ~ 5,
    recid_risk < deciles[6] ~ 6,
    recid_risk < deciles[7] ~ 7,
    recid_risk < deciles[8] ~ 8,
    recid_risk < deciles[9] ~ 9,
    recid_risk < deciles[10] ~ 10,    
  )) %>% 
  mutate(score_text = case_when(decile_score < 4 ~ 'Low', # creating score levels, like COMPAS's equivalent
                                decile_score < 8 ~ 'Medium',
                                TRUE ~ 'High'),
         score_text = factor(score_text, c('Low', 'Medium', 'High')))
```

#### a) Racial bias

```{r}
arrest_history_test %>% 
  group_by(score_text, race) %>% 
  summarise(recid_ppn = sum(recidivated == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)

```

This analysis shows no strong evidence of racial bias. Individuals classified as high-risk were approximately equally likely to recidivate (~93% probability) across all of the high-n racial groups. Medium and low-risk classifications saw only slightly more variation. However, there was very little difference in the probabilities of recidivism of African Americans and Caucasians in these categories.

#### b) Age bias

```{r age}

arrest_history_test %>% 
  group_by(score_text, arrest_age_category) %>% 
  summarise(recid_ppn = sum(recidivated == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)

```

This analysis shows evidence of a small disparity in observed probability of recidivism of high-risk individuals, across age. Mainly, high-risk classified individuals in the >45 age group were approximately 3 percentage points less likely to recidivate than individuals in the 25-45 age group, indicating slight bias against those in the oldest age group.

Furthermore, younger low-risk classified individuals were much more likely to reoffend (approximately 9 percentage points) than the oldest low-risk classified individuals.


#### c) Gender bias

```{r gender}
arrest_history_test %>% 
  group_by(score_text, sex) %>% 
  summarise(recid_ppn = sum(recidivated == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)
```

This analysis shows little evidence of a disparity in observed probability of recidivism across sex. Men and women were approximately equally likely to reoffend in each risk category.


### 6.4 Observed violent recidivism rates per-score level across demographic groups

```{r}
deciles <- c(.1, .2, .3, .4, .5, .6, .7, .8, .9, 1)


deciles <- quantile(recidivism_violent_logit.pred$yes, deciles) # generates deciles based on predicted probabilities


# adding column for raw model prediction scores
arrest_history_violent_test <- cbind(arrest_history_violent_test, predict(recidivism_violent_logit, arrest_history_violent_test, type = 'prob')$yes) %>%
  rename(recid_risk = `predict(recidivism_violent_logit, arrest_history_violent_test, `) %>% 
  mutate(decile_score = case_when( # adding column for decile score
    recid_risk < deciles[1] ~ 0,
    recid_risk < deciles[1] ~ 1,
    recid_risk < deciles[2] ~ 2,
    recid_risk < deciles[3] ~ 3,
    recid_risk < deciles[4] ~ 4,
    recid_risk < deciles[5] ~ 5,
    recid_risk < deciles[6] ~ 6,
    recid_risk < deciles[7] ~ 7,
    recid_risk < deciles[8] ~ 8,
    recid_risk < deciles[9] ~ 9,
    recid_risk < deciles[10] ~ 10,    
  )) %>% 
  mutate(score_text = case_when(decile_score < 4 ~ 'Low', # creating score levels, like COMPAS's equivalent
                                decile_score < 8 ~ 'Medium',
                                TRUE ~ 'High'),
         score_text = factor(score_text, c('Low', 'Medium', 'High')))
```


#### a) Racial bias

```{r}

arrest_history_violent_test %>% 
  group_by(score_text, race) %>% 
  summarise(recid_ppn = sum(recidivated_violent == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)


```

We see evidence of a small disparity in probability of violent reoffense across race within risk groups. Caucasians classified as high-risk are slightly (3 percentage points) less likely to violently reoffend than African Americans. And high-risk Hispanics are significantly (6 percentage points) less likely to violently reoffend than African Americans.

Medium and low-risk classifications see only small variations in probability of reoffense across race.



#### b) Age bias

```{r}

arrest_history_violent_test %>% 
  group_by(score_text, arrest_age_category) %>% 
  summarise(recid_ppn = sum(recidivated_violent == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)


```

There appears to be significant bias in our classifications across age group. Mainly, high-risk classified individuals in the oldest age category are approximately 8 percentage points less likely to violently reoffend than younger individuals classified as high risk.

Medium and low-risk classifications see only small variations in probability of violent reoffense across race.



#### c) Gender bias

```{r}

arrest_history_violent_test %>% 
  group_by(score_text, sex) %>% 
  summarise(recid_ppn = sum(recidivated_violent == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)

```

Men and women within the same risk classifications are approximately equally likely to reoffend violently.






## 7. Comparing with COMPAS

For this section, we will compare the predictions of our model on test data with COMPAS's risk assessments. 

### 7. 1 Recidivism

#### a) Creating comparison dataset

We first create a dataset that combines scores from COMPAS's recidivism risk assessment with our own scores.

We subset this data so that each row represents an arrest event that is both:
  a.) In our test set
  b.) In the set of arrests assessed by COMPAS
ensuring that we're comparing test set predictions by both models.

```{r creating decile scores r}
## must be run after train(recidivism_logit)

deciles <- c(.1, .2, .3, .4, .5, .6, .7, .8, .9, 1)

deciles <- quantile(recidivism_logit.pred$yes, deciles) # generates deciles based on predicted probabilities

# rereading arrest_history dataset
arrest_history_comparison <- read_csv("../Data/modified/arrest_history.csv") %>% 
  mutate(race = as.factor(race),
         arrest_age_category = as.factor(arrest_age_category),
         sex = as.factor(sex),
         recidivated = as.factor(recidivated),
         arrest_date = ymd(arrest_date)) %>% 
  filter(arrest_date > ymd(max(.$arrest_date)) - years(3)) # filtering by date, ensures we get rows from the test set

# adding column for raw model prediction scores
arrest_history_comparison <- cbind(arrest_history_comparison, predict(recidivism_logit, arrest_history_comparison, type = 'prob')$yes) %>%
  rename(recid_risk = `predict(recidivism_logit, arrest_history_comparison, type = "prob")$yes`) %>% 
  mutate(decile_score = case_when( # adding column for decile score
    recid_risk < deciles[1] ~ 0,
    recid_risk < deciles[1] ~ 1,
    recid_risk < deciles[2] ~ 2,
    recid_risk < deciles[3] ~ 3,
    recid_risk < deciles[4] ~ 4,
    recid_risk < deciles[5] ~ 5,
    recid_risk < deciles[6] ~ 6,
    recid_risk < deciles[7] ~ 7,
    recid_risk < deciles[8] ~ 8,
    recid_risk < deciles[9] ~ 9,
    recid_risk < deciles[10] ~ 10,    
  )) %>% 
  mutate(score_text = case_when(decile_score < 4 ~ 'Low', # creating score levels, like COMPAS's equivalent
                                decile_score < 8 ~ 'Medium',
                                TRUE ~ 'High'),
         score_text = factor(score_text, c('Low', 'Medium', 'High')))
```

```{r loading compas data}
conn <- dbConnect(drv = dbDriver('SQLite'), # tells R to use SQLite
                            '../Data/modified/compas.db') # tells R the location of our .db file

# Loading COMPAS data
compas <- dbGetQuery(conn, statement = ' 
  SELECT distinct person_id, arrest_date, compas.decile_score, compas.score_text 
    FROM casearrest JOIN people ON people.id = casearrest.person_id
  JOIN compas USING(person_id)
  WHERE arrest_date = c_offense_date AND type_of_assessment = \'Risk of Recidivism\'') %>% 
  mutate(arrest_date = as.Date(arrest_date)) %>% 
  rename(compas_decile_score = decile_score,
         compas_score_text = score_text)
```

```{r}
joined_score_data <- arrest_history_comparison %>% # Joining the two datasets on the basis of person ID & arrest_date
  left_join(compas, by=c('arrest_date', 'person_id')) %>% 
  filter(!is.na(compas_decile_score)) # Removing rows not assessed by COMPAS
```

#### b) Score Group Sizes

```{r comparing proportion of scores}
inner_join(joined_score_data %>% 
  group_by(score_text) %>% 
  summarise(score_ppn = n() / nrow(joined_score_data)),

joined_score_data %>% 
  group_by(compas_score_text) %>% 
  summarise(compas_score_ppn = n() / nrow(joined_score_data)),

by = c('score_text' = 'compas_score_text'))

```
Our model classifies a much lower proportion of individuals as high- or low-risk, than does COMPAS, meaning that it classifies many more individuals as medium risk.

#### c) Observed Recidivism Probability by Score Level

```{r recidivism risk by score level r}
recid_proportion <- joined_score_data %>% 
  group_by(score_text) %>% 
  summarise(recid_proportion = sum(recidivated == 'yes') / n())

compas_recid_proportion <- joined_score_data %>% 
  group_by(compas_score_text) %>% 
  summarise(compas_recid_proportion = sum(recidivated == 'yes') / n())


left_join(recid_proportion, compas_recid_proportion, by = c('score_text' = 'compas_score_text')) %>% arrange(desc(recid_proportion))
```

Both models' score levels correspond to very similar recidivism risks.

```{r recidivism risk by score level and race}
# African American, Caucasian, and Hispanic individuals are most highly represented in the data.

joined_score_data %>% 
  group_by(race) %>% 
  summarise(n())

joined_score_data %>% 
  group_by(score_text, race) %>% 
  summarise(recid_ppn = sum(recidivated == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn)

joined_score_data %>% 
  group_by(compas_score_text, race) %>% 
  summarise(recid_ppn = sum(recidivated == 'yes') / n()) %>% 
  pivot_wider(names_from = compas_score_text, values_from = recid_ppn)
```

In our model's predictions, recidivism rate per score-group is very similar across race (in the case of the three well-represented race groups, African-Americans, Caucasians, and Hispanics). 

Recidivism rate per-score group varies among racial groups in the COMPAS model. Mainly, within the high risk group, African Americans are about 3 percentage points more likely to recidivate than Caucasians, and Hispanics are about 7 percentage points less likely to recidivate than Caucasians. 

This suggests that our model's score level classifications may be more equitable by race, than COMPAS's.



### 7. 2 Violent Recidivism


```{r creating decile scores vr}
## must be run after train(recidivism_logit)

deciles <- c(.1, .2, .3, .4, .5, .6, .7, .8, .9, 1)

deciles <- quantile(recidivism_violent_boost.pred$yes, deciles) # generates deciles based on predicted probabilities

# rereading arrest_history dataset
arrest_history_violent_comparison <- read_csv("../Data/modified/arrest_history_violent.csv") %>% 
  mutate(race = as.factor(race),
         arrest_age_category = as.factor(arrest_age_category),
         sex = as.factor(sex),
         recidivated_violent = as.factor(recidivated_violent),
         arrest_date = ymd(arrest_date)) %>% 
  filter(arrest_date > ymd(max(.$arrest_date)) - years(3)) # filtering by date, ensures we get rows from the test set

# adding column for raw model prediction scores
arrest_history_violent_comparison <- cbind(arrest_history_violent_comparison, predict(recidivism_violent_boost, arrest_history_violent_comparison, type = 'prob')$yes) %>%
  rename(recid_violent_risk = `predict(recidivism_violent_boost, arrest_history_violent_comparison, `) %>% 
  mutate(decile_score = case_when( # adding column for decile score
    recid_violent_risk < deciles[1] ~ 0,
    recid_violent_risk < deciles[1] ~ 1,
    recid_violent_risk < deciles[2] ~ 2,
    recid_violent_risk < deciles[3] ~ 3,
    recid_violent_risk < deciles[4] ~ 4,
    recid_violent_risk < deciles[5] ~ 5,
    recid_violent_risk < deciles[6] ~ 6,
    recid_violent_risk < deciles[7] ~ 7,
    recid_violent_risk < deciles[8] ~ 8,
    recid_violent_risk < deciles[9] ~ 9,
    recid_violent_risk < deciles[10] ~ 10,    
  )) %>% 
  mutate(score_text = case_when(decile_score < 4 ~ 'Low', # creating score levels, like COMPAS's equivalent
                                decile_score < 8 ~ 'Medium',
                                TRUE ~ 'High'))
```

```{r}
conn <- dbConnect(drv = dbDriver('SQLite'), # tells R to use SQLite
                            '../Data/modified/compas.db') # tells R the location of our .db file

# Loading COMPAS data
compas_violent <- dbGetQuery(conn, statement = ' 
  SELECT distinct person_id, arrest_date, compas.decile_score, compas.score_text 
    FROM casearrest JOIN people ON people.id = casearrest.person_id
  JOIN compas USING(person_id)
  WHERE arrest_date = c_offense_date AND type_of_assessment = \'Risk of Recidivism\'') %>% 
  mutate(arrest_date = as.Date(arrest_date)) %>% 
  rename(compas_decile_score = decile_score,
         compas_score_text = score_text)
```

```{r}
joined_score_data_violent <- arrest_history_violent_comparison %>% # Joining the two datasets on the basis of person ID & arrest_date
  left_join(compas, by=c('arrest_date', 'person_id')) %>% 
  filter(!is.na(compas_decile_score)) %>%  # Removing rows not assessed by COMPAS
  mutate(score_text = factor(score_text, c('High', 'Medium', 'Low')),
         compas_score_text = factor(compas_score_text, c('High', 'Medium', 'Low')))
```

#### a) Score Group Sizes

```{r comparing proportion of scores r}
inner_join(joined_score_data_violent %>% 
  group_by(score_text) %>% 
  summarise(score_ppn = n() / nrow(joined_score_data)),

joined_score_data_violent %>% 
  group_by(compas_score_text) %>% 
  summarise(compas_score_ppn = n() / nrow(joined_score_data)),

by = c('score_text' = 'compas_score_text'))

```
Again, our model classifies a higher proportion of individuals as medium-risk, and fewer as low- or high-risk, than does COMPAS.

#### b) Observed Recidivism Probability by Score Level

```{r recidivism risk by score level}
recid_proportion <- joined_score_data_violent %>% 
  group_by(score_text) %>% 
  summarise(violent_recid_proportion = sum(recidivated_violent == 'yes') / n())

compas_recid_proportion <- joined_score_data_violent %>% 
  group_by(compas_score_text) %>% 
  summarise(compas_violent_recid_proportion = sum(recidivated_violent == 'yes') / n())


left_join(recid_proportion, compas_recid_proportion, by = c('score_text' = 'compas_score_text')) %>% arrange(desc(violent_recid_proportion))
```

Both models' score levels are associated with very similar probabilities of violent recidivism.

```{r recidivism risk by score level and race r}
# African American, Caucasian, and Hispanic individuals are most highly represented in the data.

joined_score_data_violent %>% 
  group_by(race) %>% 
  summarise(n())

joined_score_data_violent %>% 
  group_by(score_text, race) %>% 
  summarise(recid_ppn = sum(recidivated_violent == 'yes') / n()) %>% 
  pivot_wider(names_from = score_text, values_from = recid_ppn) %>% 
  arrange(race)

joined_score_data_violent %>% 
  group_by(compas_score_text, race) %>% 
  summarise(recid_ppn = sum(recidivated_violent == 'yes') / n()) %>% 
  pivot_wider(names_from = compas_score_text, values_from = recid_ppn) %>% 
  arrange(race)
```
In our model, probability of violent recidivism varies between race groups. African Americans rated as high-risk are slightly more likely than Caucasians to reoffend violently. And high-risk Hispanics are significantly (5 percentage points) less likely.

In COMPAS's predictions, observed probability is basically the same for high-risk African Americans and Caucasians, but significantly lower (~5 percentage points) for high-risk Hispanics.

### 7.3 Conclusion

Our model's predictions of recidivism score risk are comparable to those of COMPAS's, in how they predict probability of recidivism. Furthermore, our model may be more equitable in how its score levels predict recidivism across race.

Likewise, our model's predictions of violent recidivism risk score are comparable to those of COMPAS's, in how they predict observed probability of recidivism. However, both our model and COMPAS's model are somewhat inequatitable in how violent recidivism risk scores are assigned across race.